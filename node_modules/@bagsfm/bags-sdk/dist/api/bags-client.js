"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ApiError = exports.BagsApiClient = void 0;
exports.createBagsAxiosInstance = createBagsAxiosInstance;
const axios_1 = __importDefault(require("axios"));
const constants_1 = require("../constants");
class BagsApiClient {
    constructor(apiKey, baseUrl = constants_1.BAGS_PUBLIC_API_V2_DEFAULT_BASE_URL, options = {}) {
        this.client = createBagsAxiosInstance(baseUrl, apiKey, options);
    }
    async handleResponse(responsePromise) {
        const response = await responsePromise;
        const { data } = response;
        if (data.success == true) {
            return data.response;
        }
        else {
            throw new ApiError(data.error, response.config, response.status, data);
        }
    }
    async get(url, config) {
        return this.handleResponse(this.client.get(url, config));
    }
    async post(url, data, config) {
        return this.handleResponse(this.client.post(url, data, config));
    }
    async put(url, data, config) {
        return this.handleResponse(this.client.put(url, data, config));
    }
    async delete(url, config) {
        return this.handleResponse(this.client.delete(url, config));
    }
}
exports.BagsApiClient = BagsApiClient;
class ApiError extends Error {
    constructor(message, config, status, data) {
        super(message);
        this.name = 'ApiError';
        this.url = config.url || 'unknown URL';
        this.method = config.method?.toUpperCase();
        this.status = status;
        this.data = data;
    }
}
exports.ApiError = ApiError;
function createBagsAxiosInstance(baseUrl, apiKey, additionalAxiosConfig = {}) {
    const axiosInstance = axios_1.default.create({
        baseURL: baseUrl,
        timeout: 60000,
        ...additionalAxiosConfig,
    });
    axiosInstance.interceptors.request.use((config) => {
        config.headers['x-api-key'] = apiKey;
        return config;
    }, (error) => Promise.reject(new ApiError('Request configuration error', error.config || {}, undefined, error)));
    axiosInstance.interceptors.response.use((res) => {
        return res;
    }, (err) => {
        const cfg = err.config ?? { url: undefined, method: undefined };
        let msg = 'An unexpected error occurred';
        let status;
        let payload;
        if (err.response) {
            status = err.response.status;
            const d = err.response.data;
            payload = d;
            if (d && typeof d === 'object' && 'success' in d && d.success === false && 'error' in d) {
                msg = d.error;
            }
            else if (d && typeof d === 'object' && 'message' in d) {
                msg = d.message;
            }
            else if (status) {
                msg = `Request failed with status ${status}`;
            }
        }
        else if (err.request) {
            msg = 'No response received from server';
        }
        else {
            msg = err.message;
        }
        const apiErr = new ApiError(msg, cfg, status, payload);
        return Promise.reject(apiErr);
    });
    return axiosInstance;
}
//# sourceMappingURL=bags-client.js.map