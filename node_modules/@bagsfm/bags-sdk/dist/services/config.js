"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConfigService = void 0;
const web3_js_1 = require("@solana/web3.js");
const base_1 = require("./base");
const constants_1 = require("../constants");
const helpers_1 = require("../utils/helpers");
const validations_1 = require("../utils/validations");
const bs58_1 = __importDefault(require("bs58"));
class ConfigService extends base_1.BaseService {
    constructor(apiKey, connection, commitment = 'processed') {
        super(apiKey, connection, commitment);
    }
    async getConfigCreationLookupTableTransactions(args, tipConfig) {
        if (args.feeClaimers.length <= constants_1.BAGS_FEE_SHARE_V2_MAX_CLAIMERS_NON_LUT) {
            console.warn('A lookup table is not needed for this config creation');
            return null;
        }
        const lutAccounts = args.feeClaimers.map((claimer) => claimer.user);
        const [createLutIx, lookupTableAddress] = web3_js_1.AddressLookupTableProgram.createLookupTable({
            authority: args.payer,
            payer: args.payer,
            recentSlot: await this.connection.getSlot(this.commitment),
        });
        const recentBlockhash = await this.connection.getLatestBlockhash(this.commitment);
        const createLutTransaction = new web3_js_1.VersionedTransaction(new web3_js_1.TransactionMessage({
            payerKey: args.payer,
            recentBlockhash: recentBlockhash.blockhash,
            instructions: [
                web3_js_1.ComputeBudgetProgram.setComputeUnitLimit({
                    units: 30000,
                }),
                web3_js_1.ComputeBudgetProgram.setComputeUnitPrice({
                    microLamports: 40000,
                }),
                createLutIx,
                tipConfig
                    ? web3_js_1.SystemProgram.transfer({
                        fromPubkey: args.payer,
                        toPubkey: tipConfig.tipWallet,
                        lamports: tipConfig.tipLamports,
                    })
                    : undefined,
            ],
        }).compileToV0Message());
        const lutAccountChunks = (0, helpers_1.chunkArray)(lutAccounts, 25);
        const extendTransactions = [];
        for (const chunk of lutAccountChunks) {
            const extendLutIx = web3_js_1.AddressLookupTableProgram.extendLookupTable({
                lookupTable: lookupTableAddress,
                authority: args.payer,
                payer: args.payer,
                addresses: chunk,
            });
            const extendLutTransaction = new web3_js_1.VersionedTransaction(new web3_js_1.TransactionMessage({
                payerKey: args.payer,
                recentBlockhash: recentBlockhash.blockhash,
                instructions: [
                    web3_js_1.ComputeBudgetProgram.setComputeUnitLimit({
                        units: 30000,
                    }),
                    web3_js_1.ComputeBudgetProgram.setComputeUnitPrice({
                        microLamports: 40000,
                    }),
                    extendLutIx,
                    tipConfig
                        ? web3_js_1.SystemProgram.transfer({
                            fromPubkey: args.payer,
                            toPubkey: tipConfig.tipWallet,
                            lamports: tipConfig.tipLamports,
                        })
                        : undefined,
                ],
            }).compileToV0Message());
            extendTransactions.push(extendLutTransaction);
        }
        return {
            creationTransaction: createLutTransaction,
            extendTransactions,
            lutAddresses: [lookupTableAddress],
        };
    }
    async createBagsFeeShareConfig(args, tipConfig) {
        const normalizedParams = (0, validations_1.validateAndNormalizeCreateFeeShareConfigParams)(args, tipConfig);
        const response = await this.bagsApiClient.post('/fee-share/config', normalizedParams);
        if (!response.needsCreation) {
            throw new Error('Config already exists');
        }
        const transactions = response.transactions?.map((transaction) => {
            const decodedTransaction = bs58_1.default.decode(transaction.transaction);
            return web3_js_1.VersionedTransaction.deserialize(decodedTransaction);
        });
        const bundles = response.bundles?.map((bundle) => {
            return bundle.map((transaction) => {
                const decodedTransaction = bs58_1.default.decode(transaction.transaction);
                return web3_js_1.VersionedTransaction.deserialize(decodedTransaction);
            });
        });
        return {
            transactions,
            bundles,
            meteoraConfigKey: new web3_js_1.PublicKey(response.meteoraConfigKey),
        };
    }
}
exports.ConfigService = ConfigService;
//# sourceMappingURL=config.js.map