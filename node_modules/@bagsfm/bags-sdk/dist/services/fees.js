"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FeesService = void 0;
const web3_js_1 = require("@solana/web3.js");
const base_1 = require("./base");
const fee_claim_1 = require("../utils/fee-claim");
const constants_1 = require("../constants");
const bs58_1 = __importDefault(require("bs58"));
class FeesService extends base_1.BaseService {
    constructor(apiKey, connection, commitment = 'processed') {
        super(apiKey, connection, commitment);
    }
    async getAllClaimablePositions(wallet) {
        const response = await this.bagsApiClient.get('/token-launch/claimable-positions', {
            params: {
                wallet: wallet.toBase58(),
            },
        });
        return response;
    }
    async getClaimTransaction(wallet, position) {
        const params = {
            feeClaimer: wallet.toBase58(),
            tokenMint: position.baseMint,
        };
        if (position.isCustomFeeVault === false) {
            if (position.virtualPoolClaimableAmount) {
                params.claimVirtualPoolFees = true;
                params.virtualPoolAddress = position.virtualPoolAddress;
            }
            if (position.dammPoolClaimableAmount) {
                params.claimDammV2Fees = true;
                params.dammV2Position = position.dammPositionInfo.position;
                params.dammV2Pool = position.dammPositionInfo.pool;
                params.dammV2PositionNftAccount = position.dammPositionInfo.positionNftAccount;
                params.tokenAMint = position.dammPositionInfo.tokenAMint;
                params.tokenBMint = position.dammPositionInfo.tokenBMint;
                params.tokenAVault = position.dammPositionInfo.tokenAVault;
                params.tokenBVault = position.dammPositionInfo.tokenBVault;
            }
        }
        else if (position.programId === constants_1.BAGS_FEE_SHARE_V1_PROGRAM_ID) {
            params.feeShareProgramId = position.programId;
            params.isCustomFeeVault = true;
            if (position.virtualPoolClaimableAmount) {
                params.claimVirtualPoolFees = true;
                params.virtualPoolAddress = position.virtualPoolAddress;
            }
            if (position.dammPoolClaimableAmount) {
                params.claimDammV2Fees = true;
                params.dammV2Position = position.dammPositionInfo.position;
                params.dammV2Pool = position.dammPositionInfo.pool;
                params.dammV2PositionNftAccount = position.dammPositionInfo.positionNftAccount;
                params.tokenAMint = position.dammPositionInfo.tokenAMint;
                params.tokenBMint = position.dammPositionInfo.tokenBMint;
                params.tokenAVault = position.dammPositionInfo.tokenAVault;
                params.tokenBVault = position.dammPositionInfo.tokenBVault;
            }
            params.customFeeVaultClaimerA = position.customFeeVaultClaimerA;
            params.customFeeVaultClaimerB = position.customFeeVaultClaimerB;
            params.customFeeVaultClaimerSide = position.customFeeVaultClaimerSide;
            const userFeeVaultPda = (0, fee_claim_1.getFeeVaultPda)(position.customFeeVaultClaimerSide === 'A' ? new web3_js_1.PublicKey(position.customFeeVaultClaimerA) : new web3_js_1.PublicKey(position.customFeeVaultClaimerB), new web3_js_1.PublicKey(position.baseMint), new web3_js_1.PublicKey(position.programId));
            const userFeeVaultPdaBalance = await this.connection.getBalance(userFeeVaultPda, this.commitment);
            const hasFeesInVault = userFeeVaultPdaBalance >= constants_1.BAGS_METEORA_FEE_CLAIMER_VAULT_RENT_EXCEMPT_AMOUNT;
            if (hasFeesInVault) {
                params.claimVirtualPoolFees = true;
                params.virtualPoolAddress = position.virtualPoolAddress;
            }
        }
        else if (position.programId === constants_1.BAGS_FEE_SHARE_V2_PROGRAM_ID) {
            params.feeShareProgramId = position.programId;
            params.isCustomFeeVault = true;
            params.tokenAMint = position.baseMint;
            params.tokenBMint = position.quoteMint;
            if (position.virtualPoolClaimableLamportsUserShare) {
                params.claimVirtualPoolFees = true;
                params.virtualPoolAddress = position.virtualPool;
            }
            if (position.isMigrated && position.dammPoolClaimableLamportsUserShare) {
                params.claimDammV2Fees = true;
                params.dammV2Pool = position.dammPositionInfo.pool;
                params.dammV2Position = position.dammPositionInfo.position;
                params.dammV2PositionNftAccount = position.dammPositionInfo.positionNftAccount;
                params.tokenAMint = position.dammPositionInfo.tokenAMint;
                params.tokenBMint = position.dammPositionInfo.tokenBMint;
                params.tokenAVault = position.dammPositionInfo.tokenAVault;
                params.tokenBVault = position.dammPositionInfo.tokenBVault;
            }
        }
        else {
            throw new Error(`Unsupported program ID: ${position.programId}. Expected '${constants_1.BAGS_FEE_SHARE_V1_PROGRAM_ID}' or '${constants_1.BAGS_FEE_SHARE_V2_PROGRAM_ID}'`);
        }
        const response = await this.bagsApiClient.post('/token-launch/claim-txs/v2', params);
        const deserializedTransactions = response.map((tx) => {
            const decodedTransaction = bs58_1.default.decode(tx.tx);
            return web3_js_1.Transaction.from(decodedTransaction);
        });
        return deserializedTransactions;
    }
}
exports.FeesService = FeesService;
//# sourceMappingURL=fees.js.map